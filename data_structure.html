<!DOCTYPE html>
<html>
<head>
<title>data_structure.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="data-structure">Data Structure</h1>
<h2 id="question-1-%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E9%93%BE%E8%A1%A8">Question 1: 链表的基本操作 (链表)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>链表最最常见的操作，一文读懂链表的代码操作，使用3种语言实现链表的7种操作。
链表的常见操作包括：</p>
<ol>
<li>插入</li>
</ol>
<ul>
<li>在头部插入： 在链表的开头添加一个新元素。</li>
<li>在尾部插入： 在链表的末尾添加一个新元素。</li>
<li>在中间插入： 在链表的任意位置插入一个新元素。</li>
</ul>
<ol start="2">
<li>删除</li>
</ol>
<ul>
<li>删除头节点： 删除链表的第一个元素。</li>
<li>删除尾节点： 删除链表的最后一个元素。</li>
<li>删除中间节点： 删除链表中的任意一个元素。</li>
</ul>
<ol start="3">
<li>遍历</li>
</ol>
<ul>
<li>正向遍历： 从链表的头部开始，依次访问每个元素，直到尾部。</li>
<li>反向遍历： 从链表的尾部开始，依次访问每个元素，直到头部。</li>
</ul>
<ol start="4">
<li>查找</li>
</ol>
<ul>
<li>按值查找： 在链表中查找特定值的节点。</li>
</ul>
<ol start="5">
<li>反转</li>
</ol>
<ul>
<li>翻转链表： 将链表的顺序颠倒过来。</li>
</ul>
<ol start="6">
<li>合并</li>
</ol>
<ul>
<li>合并两个有序链表： 将两个有序链表合并成一个有序链表。</li>
</ul>
<ol start="7">
<li>环检测</li>
</ol>
<ul>
<li>检测链表中是否存在环： 判断链表是否形成了循环。</li>
</ul>
<p>这些基本的链表操作在算法和数据结构中经常被使用，它们构成了链表数据结构的基础。链表相对于数组的优势之一是在插入和删除元素时更为高效，但在查找元素时效率较低。</p>
<h4 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">解题思路</h4>
<h4 id="c">C++：</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> data;
    Node* next;

    Node(<span class="hljs-keyword">int</span> value) : data(value), next(<span class="hljs-literal">nullptr</span>) {}
};

<span class="hljs-comment">// 在头部插入</span>
<span class="hljs-function">Node* <span class="hljs-title">insertAtHead</span><span class="hljs-params">(Node* head, <span class="hljs-keyword">int</span> value)</span> </span>{
    Node* newNode = <span class="hljs-keyword">new</span> Node(value);
    newNode-&gt;next = head;
    <span class="hljs-keyword">return</span> newNode;
}

<span class="hljs-comment">// 在尾部插入</span>
<span class="hljs-function">Node* <span class="hljs-title">insertAtTail</span><span class="hljs-params">(Node* head, <span class="hljs-keyword">int</span> value)</span> </span>{
    Node* newNode = <span class="hljs-keyword">new</span> Node(value);
    newNode-&gt;next = <span class="hljs-literal">nullptr</span>;

    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span> newNode;
    }

    Node* current = head;
    <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) {
        current = current-&gt;next;
    }
    current-&gt;next = newNode;

    <span class="hljs-keyword">return</span> head;
}

<span class="hljs-comment">// 在中间插入</span>
<span class="hljs-function">Node* <span class="hljs-title">insertInMiddle</span><span class="hljs-params">(Node* head, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> position)</span> </span>{
    Node* newNode = <span class="hljs-keyword">new</span> Node(value);

    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) {
        newNode-&gt;next = head;
        <span class="hljs-keyword">return</span> newNode;
    }

    Node* current = head;
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">1</span> &amp;&amp; current != <span class="hljs-literal">nullptr</span>) {
        current = current-&gt;next;
        count++;
    }

    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">delete</span> newNode;
        <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// 插入位置超过链表长度，不进行插入</span>
    }

    newNode-&gt;next = current-&gt;next;
    current-&gt;next = newNode;

    <span class="hljs-keyword">return</span> head;
}

<span class="hljs-comment">// 删除头节点</span>
<span class="hljs-function">Node* <span class="hljs-title">deleteHead</span><span class="hljs-params">(Node* head)</span> </span>{
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    }
    Node* newHead = head-&gt;next;
    <span class="hljs-keyword">delete</span> head;
    <span class="hljs-keyword">return</span> newHead;
}

<span class="hljs-comment">// 删除尾节点</span>
<span class="hljs-function">Node* <span class="hljs-title">deleteTail</span><span class="hljs-params">(Node* head)</span> </span>{
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    }

    <span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">delete</span> head;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    }

    Node* current = head;
    <span class="hljs-keyword">while</span> (current-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) {
        current = current-&gt;next;
    }

    <span class="hljs-keyword">delete</span> current-&gt;next;
    current-&gt;next = <span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">return</span> head;
}

<span class="hljs-comment">// 删除中间节点</span>
<span class="hljs-function">Node* <span class="hljs-title">deleteFromMiddle</span><span class="hljs-params">(Node* head, <span class="hljs-keyword">int</span> position)</span> </span>{
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    }

    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) {
        Node* newHead = head-&gt;next;
        <span class="hljs-keyword">delete</span> head;
        <span class="hljs-keyword">return</span> newHead;
    }

    Node* current = head;
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (count &lt; position - <span class="hljs-number">1</span> &amp;&amp; current != <span class="hljs-literal">nullptr</span>) {
        current = current-&gt;next;
        count++;
    }

    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span> || current-&gt;next == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// 删除位置超过链表长度，不进行删除</span>
    }

    Node* temp = current-&gt;next;
    current-&gt;next = current-&gt;next-&gt;next;
    <span class="hljs-keyword">delete</span> temp;

    <span class="hljs-keyword">return</span> head;
}

<span class="hljs-comment">// 正向遍历</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(Node* head)</span> </span>{
    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; head-&gt;data &lt;&lt; <span class="hljs-string">" "</span>;
        head = head-&gt;next;
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}

<span class="hljs-comment">// 反向遍历</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseTraverse</span><span class="hljs-params">(Node* head)</span> </span>{
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">return</span>;
    }

    reverseTraverse(head-&gt;next);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; head-&gt;data &lt;&lt; <span class="hljs-string">" "</span>;
}

<span class="hljs-comment">// 查找</span>
<span class="hljs-function">Node* <span class="hljs-title">search</span><span class="hljs-params">(Node* head, <span class="hljs-keyword">int</span> value)</span> </span>{
    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-keyword">if</span> (head-&gt;data == value) {
            <span class="hljs-keyword">return</span> head;
        }
        head = head-&gt;next;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}

<span class="hljs-comment">// 翻转链表</span>
<span class="hljs-function">Node* <span class="hljs-title">reverseList</span><span class="hljs-params">(Node* head)</span> </span>{
    Node* prev = <span class="hljs-literal">nullptr</span>;
    Node* current = head;
    Node* next = <span class="hljs-literal">nullptr</span>;

    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) {
        next = current-&gt;next;
        current-&gt;next = prev;
        prev = current;
        current = next;
    }

    <span class="hljs-keyword">return</span> prev;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Node* head = <span class="hljs-literal">nullptr</span>;

    <span class="hljs-comment">// 在头部插入</span>
    head = insertAtHead(head, <span class="hljs-number">3</span>);
    head = insertAtHead(head, <span class="hljs-number">2</span>);
    head = insertAtHead(head, <span class="hljs-number">1</span>);

    <span class="hljs-comment">// 在尾部插入</span>
    head = insertAtTail(head, <span class="hljs-number">4</span>);
    head = insertAtTail(head, <span class="hljs-number">5</span>);

    <span class="hljs-comment">// 在中间插入</span>
    head = insertInMiddle(head, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>);

    <span class="hljs-comment">// 删除头节点</span>
    head = deleteHead(head);

    <span class="hljs-comment">// 删除尾节点</span>
    head = deleteTail(head);

    <span class="hljs-comment">// 删除中间节点</span>
    head = deleteFromMiddle(head, <span class="hljs-number">2</span>);

    <span class="hljs-comment">// 正向遍历</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Forward Traverse: "</span>;
    traverse(head);

    <span class="hljs-comment">// 反向遍历</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Reverse Traverse: "</span>;
    reverseTraverse(head);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

    <span class="hljs-comment">// 查找</span>
    Node* searchResult = search(head, <span class="hljs-number">10</span>);
    <span class="hljs-keyword">if</span> (searchResult != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Found: "</span> &lt;&lt; searchResult-&gt;data &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Not Found"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-comment">// 翻转链表</span>
    head = reverseList(head);

    <span class="hljs-comment">// 正向遍历翻转后的链表</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Forward Traverse (Reversed): "</span>;
    traverse(head);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-2-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E6%95%B0%E7%BB%84">Question 2: 数组的基本操作 (数组)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>数组是一种基本的数据结构，它是一组相同类型的元素的集合，通过索引或者下标来访问和操作。</p>
<p>数组的常见操作包括：
各类操作</p>
<ol>
<li>创建数组：</li>
</ol>
<ul>
<li>原理： 分配一块连续的内存空间，用于存储数组元素。</li>
<li>方式： 在大多数编程语言中，通过声明数组类型和大小来创建数组。例如，在C语言中，可以使用int myArray[5];来创建一个包含5个整数的数组。</li>
</ul>
<ol start="2">
<li>访问元素：</li>
</ol>
<ul>
<li>原理： 数组元素存储在连续的内存地址中，可以通过索引或下标来访问。</li>
<li>方式： 使用数组的索引或下标，例如myArray[2]表示访问数组中的第三个元素。</li>
</ul>
<ol start="3">
<li>插入元素：</li>
</ol>
<ul>
<li>原理： 在指定位置插入新元素，需要将插入点后的元素向后移动，腾出位置。</li>
<li>方式：
在指定位置插入元素，并移动后续元素。
在末尾插入元素时，直接在数组末尾添加元素即可。</li>
</ul>
<ol start="4">
<li>删除元素：</li>
</ol>
<ul>
<li>原理： 删除指定位置的元素，需要将删除点后的元素向前移动，填补删除位置。</li>
<li>方式：
删除指定位置的元素，并移动后续元素。
在末尾删除元素时，直接缩小数组大小。</li>
</ul>
<ol start="5">
<li>查找元素：</li>
</ol>
<ul>
<li>原理： 遍历数组元素，逐一比较查找值。</li>
<li>方式：
<ul>
<li>线性查找：逐一比较，直到找到匹配的元素。</li>
<li>二分查找：仅适用于有序数组，通过比较中间元素确定查找方向。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>数组的遍历：</li>
</ol>
<ul>
<li>原理： 逐一访问数组中的每个元素。</li>
<li>方式： 使用循环结构，如for循环或while循环，从数组的第一个元素遍历到最后一个。</li>
</ul>
<ol start="7">
<li>数组的合并和拆分：</li>
</ol>
<ul>
<li>原理：
<ul>
<li>合并：将两个数组的元素整合到一个新数组中。</li>
<li>拆分：将一个数组的元素拆分成两个或多个数组。</li>
</ul>
</li>
<li>方式：
<ul>
<li>合并：创建一个新数组，将两个数组的元素逐一复制到新数组中。</li>
<li>拆分：指定拆分点，将元素分配到不同的数组中。</li>
</ul>
</li>
</ul>
<h4 id="c">C++:</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 1. 创建数组</span>
    <span class="hljs-keyword">int</span> myArray[<span class="hljs-number">5</span>];

    <span class="hljs-comment">// 2. 访问元素</span>
    <span class="hljs-keyword">int</span> value = myArray[<span class="hljs-number">2</span>];

    <span class="hljs-comment">// 3. 插入元素（在指定位置插入新元素）</span>
    <span class="hljs-keyword">int</span> newValue = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">4</span>; i &gt;= index; i--) {
        myArray[i + <span class="hljs-number">1</span>] = myArray[i];
    }
    myArray[index] = newValue;

    <span class="hljs-comment">// 4. 删除元素（在指定位置删除元素）</span>
    <span class="hljs-keyword">int</span> deleteIndex = <span class="hljs-number">2</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = deleteIndex; i &lt; <span class="hljs-number">4</span>; i++) {
        myArray[i] = myArray[i + <span class="hljs-number">1</span>];
    }

    <span class="hljs-comment">// 5. 查找元素（线性查找）</span>
    <span class="hljs-keyword">int</span> searchValue = <span class="hljs-number">10</span>;
    <span class="hljs-keyword">int</span> searchIndex = <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        <span class="hljs-keyword">if</span> (myArray[i] == searchValue) {
            searchIndex = i;
            <span class="hljs-keyword">break</span>;
        }
    }

    <span class="hljs-comment">// 6. 数组的遍历</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
        <span class="hljs-comment">// 访问myArray[i]</span>
    }

    <span class="hljs-comment">// 7. 数组的合并和拆分</span>
    <span class="hljs-keyword">int</span> myArray1[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-keyword">int</span> myArray2[<span class="hljs-number">5</span>] = {<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>};

    <span class="hljs-comment">// 合并数组</span>
    <span class="hljs-keyword">int</span> newArray[<span class="hljs-number">10</span>];
    <span class="hljs-built_in">std</span>::copy(myArray1, myArray1 + <span class="hljs-number">5</span>, newArray);
    <span class="hljs-built_in">std</span>::copy(myArray2, myArray2 + <span class="hljs-number">5</span>, newArray + <span class="hljs-number">5</span>);

    <span class="hljs-comment">// 拆分数组</span>
    <span class="hljs-keyword">int</span> splitIndex = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span> newArray1[splitIndex];
    <span class="hljs-keyword">int</span> newArray2[<span class="hljs-number">5</span> - splitIndex];
    <span class="hljs-built_in">std</span>::copy(myArray, myArray + splitIndex, newArray1);
    <span class="hljs-built_in">std</span>::copy(myArray + splitIndex, myArray + <span class="hljs-number">5</span>, newArray2);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</div></code></pre>
<h2 id="question-3-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-%E6%A0%88">Question 3: 栈的基本操作 (栈)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>Stack, 中文又稱為堆疊，是一種具有後進先出（Last In First Out, LIFO）特性的抽象資料型別，常用的操作有push（壓入）、pop（彈出）、top（取得頂端元素）、empty（判斷是否為空）等。</p>
<p>Stack的常見應用場景包括：</p>
<ol>
<li>函數調用堆疊： 當一個函數被調用時，一個新的堆疊框架會被壓入堆疊中。當函數返回時，這個堆疊框架會被彈出。</li>
<li>表達式求值： 在編譯器中，堆疊被用於表達式的求值。例如，中綴表達式（3 + 4）* 5的求值過程中，運算符和操作數被壓入堆疊中，然後彈出進行運算。</li>
<li>括號匹配： 堆疊被用於括號匹配的檢查。例如，當我們讀取到一個左括號時，我們將其壓入堆疊中，當我們讀取到一個右括號時，我們彈出堆疊中的左括號，如果彈出的括號與當前的右括號不匹配，則表示括號不匹配。</li>
<li>瀏覽器的回退功能： 瀏覽器的回退功能通常使用堆疊來實現。當我們訪問一個網頁時，它被壓入堆疊中，當我們點擊回退按鈕時，它被彈出堆疊中。</li>
</ol>
<h4 id="stack%E7%9A%84%E5%B8%B8%E8%A6%8B%E6%93%8D%E4%BD%9C%E5%8C%85%E6%8B%AC">Stack的常見操作包括：</h4>
<h4 id="c-%E8%AF%AD%E8%A8%80">C++ 语言</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> {</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; data;

<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// 初始化栈</span>
    Stack() {}

    <span class="hljs-comment">// 压栈</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
        data.push_back(value);
    }

    <span class="hljs-comment">// 弹栈</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Stack underflow\n"</span>;
            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
        }
        <span class="hljs-keyword">int</span> value = data.back();
        data.pop_back();
        <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-comment">// 获取栈顶元素</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">if</span> (isEmpty()) {
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"Stack is empty\n"</span>;
            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);
        }
        <span class="hljs-keyword">return</span> data.back();
    }

    <span class="hljs-comment">// 判空</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> data.empty();
    }

    <span class="hljs-comment">// 获取栈的大小</span>
    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{
        <span class="hljs-keyword">return</span> data.size();
    }

    <span class="hljs-comment">// 清空栈</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>{
        data.clear();
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    Stack <span class="hljs-built_in">stack</span>;

    <span class="hljs-built_in">stack</span>.push(<span class="hljs-number">10</span>);
    <span class="hljs-built_in">stack</span>.push(<span class="hljs-number">20</span>);
    <span class="hljs-built_in">stack</span>.push(<span class="hljs-number">30</span>);

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Top element: "</span> &lt;&lt; <span class="hljs-built_in">stack</span>.top() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Stack size: "</span> &lt;&lt; <span class="hljs-built_in">stack</span>.size() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">stack</span>.pop();

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"After pop, top element: "</span> &lt;&lt; <span class="hljs-built_in">stack</span>.top() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is stack empty? "</span> &lt;&lt; (<span class="hljs-built_in">stack</span>.isEmpty() ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

    <span class="hljs-built_in">stack</span>.clear();

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Is stack empty after clear? "</span> &lt;&lt; (<span class="hljs-built_in">stack</span>.isEmpty() ? <span class="hljs-string">"Yes"</span> : <span class="hljs-string">"No"</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-4-string-search-%E9%8F%88%E8%A1%A8">Question 4: String Search (鏈表)</h2>
<pre class="hljs"><code><div>- Input <span class="hljs-number">1</span>D letter array = [E R T R, P O T Q, R I T A, S O W E]. 
- width <span class="hljs-number">4</span>, height <span class="hljs-number">4</span> → <span class="hljs-number">2</span>D matrix
- Input <span class="hljs-number">1</span>D search string: [R O T]

ERTR
POTQ 
RITA
SOWE

Check <span class="hljs-keyword">if</span> search string matches the <span class="hljs-number">1</span>st matrix diagonally. Output first location of letter <span class="hljs-string">'R'</span> → (<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)

Approach:
<span class="hljs-number">1.</span> Convert the <span class="hljs-number">1</span>D letter array to a <span class="hljs-number">2</span>D matrix
<span class="hljs-number">2.</span> Iterate through the <span class="hljs-number">2</span>D matrix <span class="hljs-keyword">and</span> check <span class="hljs-keyword">for</span> the first letter of the search string
<span class="hljs-number">3.</span> If found, start a diagonal search <span class="hljs-keyword">from</span> that position to check <span class="hljs-keyword">if</span> the search string matches
<span class="hljs-number">4.</span> If found, <span class="hljs-keyword">return</span> the position
<span class="hljs-number">5.</span> If <span class="hljs-keyword">not</span> found, <span class="hljs-keyword">return</span> <span class="hljs-string">"Not found"</span>

Detail: To solve this problem, we first need to convert the <span class="hljs-number">1</span>D letter array into a <span class="hljs-number">2</span>D matrix representation, given the width <span class="hljs-keyword">and</span> height. After that, we will search <span class="hljs-keyword">for</span> the input <span class="hljs-number">1</span>D search string within this matrix diagonally, <span class="hljs-keyword">and</span> <span class="hljs-keyword">if</span> a match <span class="hljs-keyword">is</span> found, we output the first location of the letter <span class="hljs-string">'R'</span> <span class="hljs-keyword">from</span> the search string.

Here<span class="hljs-string">'s a breakdown of the steps:

1. Convert 1D letter array to 2D matrix: Given the width and height, we can reshape the input 1D letter array into a 2D matrix.
2. Search for the search string diagonally: Starting from each element in the matrix, we attempt to match the search string diagonally (both from left to right and potentially from right to left, if needed). In this case, it seems we are only looking in a diagonal from the top left to bottom right direction.
3. Output the first location of '</span>R<span class="hljs-string">': Once a match is found, we return the first location of the letter '</span>R<span class="hljs-string">' in the matrix based on where the search string matches.

The matrix looks like this when formed:
E R T R
P O T Q
R I T A
S O W E
</span></div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">searchDiagonal</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&amp; matrix, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; search)</span> </span>{
    <span class="hljs-keyword">int</span> m = matrix.size();
    <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].size();
    <span class="hljs-keyword">int</span> len = search.size();

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) {
            <span class="hljs-keyword">if</span> (matrix[i][j] == search[<span class="hljs-number">0</span>]) {
                <span class="hljs-comment">// Check diagonal from (i, j) to (i + len - 1, j + len - 1)</span>
                <span class="hljs-keyword">int</span> x = i, y = j;
                <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">while</span> (x &lt; m &amp;&amp; y &lt; n &amp;&amp; k &lt; len) {
                    <span class="hljs-keyword">if</span> (matrix[x][y] != search[k]) {
                        <span class="hljs-keyword">break</span>;
                    }
                    x++;
                    y++;
                    k++;
                }
                <span class="hljs-keyword">if</span> (k == len) {
                    <span class="hljs-keyword">return</span> {i, j};
                }
            }
        }
    }

    <span class="hljs-keyword">return</span> {<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>};
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; matrix = {<span class="hljs-string">"ERTR"</span>, <span class="hljs-string">"POTQ"</span>, <span class="hljs-string">"RITA"</span>, <span class="hljs-string">"SOWE"</span>};
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> search = <span class="hljs-string">"ROT"</span>;

    <span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; result = searchDiagonal(matrix, search);

    <span class="hljs-keyword">if</span> (result.first == <span class="hljs-number">-1</span> &amp;&amp; result.second == <span class="hljs-number">-1</span>) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Not found"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"First location of 'R' in search string: ("</span> &lt;&lt; result.first &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; result.second &lt;&lt; <span class="hljs-string">")"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-5-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E9%93%BE%E8%A1%A8">Question 5: 两数相加 (链表)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>给定两个非空链表，表示两个非负整数。它们每位数字都是按照逆序方式存储的，并且每个节点只能存储一位数字。请将两个数相加并以相同形式返回一个表示和的链表。</p>
<p>例如：</p>
<pre class="hljs"><code><div>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
解释：342 + 465 = 807。
</div></code></pre>
<h4 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">解题思路</h4>
<ol>
<li>模拟加法过程：</li>
</ol>
<p>初始化一个虚拟节点作为结果链表的头结点，并定义一个指针指向当前节点。
使用一个变量 carry 来记录进位，初始化为0。
遍历两个链表，对于每一位进行相加，同时加上前一位的进位。
如果相加结果大于等于10，则更新进位。
创建一个新节点，其值为相加结果的个位数，连接到结果链表上。
最后检查是否有额外的进位，如果有，则添加一个值为1的新节点。
返回结果链表的头结点。</p>
<p>代码是使用模拟加法过程的思路，也是最常见、最直观的解法。该方法的基本思想是模拟手工相加的过程，逐位相加，考虑进位，生成新的链表。</p>
<p>这种方法最大的优点是清晰易懂，直接反映了加法的本质。缺点是可能稍微繁琐，需要考虑一些边界情况和细节。</p>
<p>遍历两个链表，逐位相加，并考虑进位的情况。最终得到的结果即为相加后的链表。</p>
<h4 id="c-%E8%AF%AD%E8%A8%80">C++ 语言：</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">// 定义单链表节点</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    ListNode* next;
    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">NULL</span>) {}
};

<span class="hljs-comment">// 函数声明</span>
<span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span></span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 创建两个链表</span>
    ListNode* l1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);
    l1-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);
    l1-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);

    ListNode* l2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);
    l2-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">6</span>);
    l2-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);

    <span class="hljs-comment">// 调用函数，计算结果链表</span>
    ListNode* result = addTwoNumbers(l1, l2);

    <span class="hljs-comment">// 输出结果链表的值</span>
    <span class="hljs-keyword">while</span> (result != <span class="hljs-literal">NULL</span>) {
        <span class="hljs-built_in">cout</span> &lt;&lt; result-&gt;val &lt;&lt; <span class="hljs-string">" "</span>;
        result = result-&gt;next;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">// 函数定义</span>
<span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{
    <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;
    ListNode* current = &amp;dummy;
    <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (l1 || l2 || carry) {
        <span class="hljs-keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="hljs-number">0</span>) + (l2 ? l2-&gt;val : <span class="hljs-number">0</span>) + carry;
        carry = sum / <span class="hljs-number">10</span>;

        current-&gt;next = <span class="hljs-keyword">new</span> ListNode(sum % <span class="hljs-number">10</span>);
        current = current-&gt;next;

        <span class="hljs-keyword">if</span> (l1) l1 = l1-&gt;next;
        <span class="hljs-keyword">if</span> (l2) l2 = l2-&gt;next;
    }

    <span class="hljs-keyword">return</span> dummy.next;
}
</div></code></pre>
<h2 id="question-6-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%88%90%E7%8E%AF-double-pointer-%E9%93%BE%E8%A1%A8">Question 6: 判断链表是否成环 (Double Pointer) (链表)</h2>
<p>问题：给定一个链表，判断是否成环。</p>
<h4 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</h4>
<p>解决方法的话，咱们一般情况下会立马想到有三种：</p>
<ul>
<li>快慢指针法</li>
<li>标记法</li>
<li>修改节点值法
下面，详细来说说看~</li>
</ul>
<h4 id="%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%B3%95">快慢指针法</h4>
<p>初始化两个指针，一个慢指针（slow）和一个快指针（fast），初始位置为链表的头节点（head）。</p>
<p>迭代遍历链表，每次循环中，慢指针前进一步，快指针前进两步。</p>
<p>如果链表中有环，快指针最终会追上慢指针，即两者会相遇。</p>
<p>如果链表中没有环，快指针会在某一点到达链表的末尾（即为None），此时退出循环。</p>
<p>最终判断，如果快指针在遍历过程中与慢指针相遇，则链表成环；否则，链表不成环。</p>
<p>当然，下面分别给出 C、Python 和 Java 的代码示例，使用的是快慢指针法来判断链表是否成环。在每种语言的代码中，hasCycle 函数都是实现了快慢指针算法。用于判断链表是否成环。</p>
<h4 id="c-%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81">C 语言代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">next</span>;</span>
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(struct ListNode* head)</span> </span>{
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">slow</span> = <span class="hljs-title">head</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span> = <span class="hljs-title">head</span>-&gt;<span class="hljs-title">next</span>;</span>

    <span class="hljs-keyword">while</span> (slow != fast) {
        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">NULL</span> || fast-&gt;next == <span class="hljs-literal">NULL</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// 创建链表节点</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">head</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">ListNode</span>*)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">ListNode</span>));</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">second</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">ListNode</span>*)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">ListNode</span>));</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">third</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">ListNode</span>*)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">ListNode</span>));</span>

    <span class="hljs-comment">// 设置节点值和连接关系</span>
    head-&gt;value = <span class="hljs-number">1</span>;
    head-&gt;next = second;
    second-&gt;value = <span class="hljs-number">2</span>;
    second-&gt;next = third;
    third-&gt;value = <span class="hljs-number">3</span>;
    third-&gt;next = head; <span class="hljs-comment">// 创建一个环</span>

    <span class="hljs-comment">// 判断链表是否成环</span>
    <span class="hljs-keyword">if</span> (hasCycle(head)) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The linked list has a cycle.\n"</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"The linked list does not have a cycle.\n"</span>);
    }

    <span class="hljs-comment">// 释放内存</span>
    <span class="hljs-built_in">free</span>(head);
    <span class="hljs-built_in">free</span>(second);
    <span class="hljs-built_in">free</span>(third);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-7-detecting-a-cycle-in-a-linked-list-%E9%93%BE%E8%A1%A8">Question 7: Detecting a Cycle in a Linked List (链表)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>To determine if a linked list is cyclic (i.e., contains a loop), a commonly used approach is Floyd’s Cycle-Finding Algorithm, also known as the &quot;Tortoise and the Hare&quot; algorithm. It uses two pointers that move at different speeds through the list.</p>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<ul>
<li>Initialize two pointers, <code>slow</code> and <code>fast</code>, both pointing to the head of the list.</li>
<li>Move <code>slow</code> by one step and <code>fast</code> by two steps through the list.</li>
<li>If the linked list has a cycle, <code>slow</code> and <code>fast</code> will eventually meet at some point inside the loop.</li>
<li>If <code>fast</code> reaches the end of the list (<code>null</code>), then the list is acyclic.</li>
</ul>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    T value;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;T&gt;&gt; next;
    ListNode(T value, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;T&gt;&gt; next = <span class="hljs-literal">nullptr</span>) : value(value), next(next) {}
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;T&gt;&gt; head)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;T&gt;&gt; slow = head, fast = head;
    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        <span class="hljs-keyword">if</span> (slow == fast) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// Cycle detected</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> head = <span class="hljs-built_in">std</span>::make_shared&lt;ListNode&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">3</span>, <span class="hljs-built_in">std</span>::make_shared&lt;ListNode&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-built_in">std</span>::make_shared&lt;ListNode&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">0</span>, <span class="hljs-built_in">std</span>::make_shared&lt;ListNode&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">-4</span>))));
    head-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next;  <span class="hljs-comment">// Create a cycle: -4 -&gt; 2</span>
    <span class="hljs-keyword">bool</span> result = hasCycle(head);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::boolalpha &lt;&lt; result &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// Output: true</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-8-find-the-start-of-the-cycle-in-a-linked-list-%E9%93%BE%E8%A1%A8">Question 8: Find the Start of the Cycle in a Linked List (链表)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>Once a cycle is detected using the &quot;Tortoise and the Hare&quot; algorithm, finding the start of the cycle involves:</p>
<ul>
<li>Once <code>slow</code> and <code>fast</code> meet within the cycle, reinitialize one of the pointers (say <code>fast</code>) to the head of the linked list.</li>
<li>Move both <code>slow</code> and <code>fast</code> at the same pace (one step at a time).</li>
<li>The point where they meet again is the start of the cycle.</li>
</ul>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>The reasoning behind this is based on the distances: from the head to the start of the loop, and from the meeting point to the start of the loop, being equal when traversed at the same speed.</p>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    T value;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;T&gt;&gt; next;
    ListNode(T value, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;T&gt;&gt; next = <span class="hljs-literal">nullptr</span>) : value(value), next(next) {}
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;T&gt;&gt; <span class="hljs-title">detectCycle</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;T&gt;&gt; head)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;T&gt;&gt; slow = head, fast = head;
    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
        <span class="hljs-keyword">if</span> (slow == fast) {  <span class="hljs-comment">// Cycle detected</span>
            fast = head;  <span class="hljs-comment">// Reset fast to head</span>
            <span class="hljs-keyword">while</span> (slow != fast) {  <span class="hljs-comment">// Find the start of the cycle</span>
                slow = slow-&gt;next;
                fast = fast-&gt;next;
            }
            <span class="hljs-keyword">return</span> slow;  <span class="hljs-comment">// Starting node of the cycle</span>
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">auto</span> head = <span class="hljs-built_in">std</span>::make_shared&lt;ListNode&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">3</span>, <span class="hljs-built_in">std</span>::make_shared&lt;ListNode&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">2</span>, <span class="hljs-built_in">std</span>::make_shared&lt;ListNode&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">0</span>, <span class="hljs-built_in">std</span>::make_shared&lt;ListNode&lt;<span class="hljs-keyword">int</span>&gt;&gt;(<span class="hljs-number">-4</span>))));
    head-&gt;next-&gt;next-&gt;next-&gt;next = head-&gt;next;  <span class="hljs-comment">// Create a cycle: -4 -&gt; 2</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;ListNode&lt;<span class="hljs-keyword">int</span>&gt;&gt; result = detectCycle(head);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result-&gt;value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// Output: 2</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-9-merge-two-sorted-lists-%E9%93%BE%E8%A1%A8">Question 9: Merge Two Sorted Lists (链表)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>给定两个按升序排列的链表，要求合并这两个链表，并且返回合并后的链表。要求新链表仍然按照升序排列。</p>
<ul>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;5
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5
</div></code></pre>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>为了解决这个问题，我们可以考虑使用迭代或递归的方式。在这里，我将详细说明迭代的解决思路。</p>
<ul>
<li>迭代法解决思路
首先，我们定义一个哑结点(dummy)，它的作用是作为合并后链表的头结点。同时，我们使用两个指针，分别指向两个待合并链表的当前节点。
遍历两个链表，比较当前节点的值，将较小的节点连接到合并链表的后面。然后将指向较小节点的指针向后移动一步。
重复上述步骤，直到其中一个链表遍历完毕。此时，将剩余未遍历的链表直接连接到合并链表的尾部。
返回合并后的链表的头结点。</li>
</ul>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    ListNode *next;
    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">nullptr</span>) {}
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>{
        <span class="hljs-function">ListNode <span class="hljs-title">dummy</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;
        ListNode* current = &amp;dummy;

        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) {
            <span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) {
                current-&gt;next = l1;
                l1 = l1-&gt;next;
            } <span class="hljs-keyword">else</span> {
                current-&gt;next = l2;
                l2 = l2-&gt;next;
            }
            current = current-&gt;next;
        }

        <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">nullptr</span>) {
            current-&gt;next = l1;
        } <span class="hljs-keyword">else</span> {
            current-&gt;next = l2;
        }

        <span class="hljs-keyword">return</span> dummy.next;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Example usage</span>
    ListNode* l1 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);
    l1-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);
    l1-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);

    ListNode* l2 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);
    l2-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);
    l2-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);

    Solution solution;
    ListNode* mergedList = solution.mergeTwoLists(l1, l2);

    <span class="hljs-comment">// Output the merged list</span>
    <span class="hljs-keyword">while</span> (mergedList != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; mergedList-&gt;val &lt;&lt; <span class="hljs-string">" "</span>;
        mergedList = mergedList-&gt;next;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-10-%E5%8F%8D%E8%BD%89%E9%8F%88%E8%A1%A8">Question 10: 反轉鏈表</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>LeetCode第25题，题目为<code>K个一组反转链表</code>。给定一个链表，每k个节点一组进行翻转，如果节点总数不是k的倍数，则最后剩余的节点应该保持原有顺序。</p>
<p>例如，给定链表1-&gt;2-&gt;3-&gt;4-&gt;5，k=2，应返回2-&gt;1-&gt;4-&gt;3-&gt;5。如果k=3，应返回3-&gt;2-&gt;1-&gt;4-&gt;5。</p>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>这个问题可以使用迭代或递归的方式来解决。在这里，我将详细说明迭代的解决思路。</p>
<ul>
<li>迭代法解决思路
首先，我们定义一个哑结点(dummy)，它的作用是作为翻转后链表的头结点。同时，我们使用两个指针，分别指向待翻转链表的前一个节点和后一个节点。
然后，我们使用一个循环来遍历链表。在每次循环中，我们首先判断剩余的链表长度是否大于等于 k。如果是，我们调用一个辅助函数 reverseKNodes 来翻转 k 个节点，并将翻转后的链表连接到原链表中。如果不是，我们直接返回原链表。
在辅助函数 reverseKNodes 中，我们使用三个指针来翻转 k 个节点。具体来说，我们首先定义一个哑结点(dummy)，然后使用两个指针分别指向待翻转链表的前一个节点和当前节点。然后，我们使用一个循环来遍历 k 个节点，每次循环中，我们将当前节点的 next 指针指向前一个节点，然后将前一个节点和当前节点向后移动一步。最后，我们将翻转后的链表的头结点返回。</li>
</ul>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> {</span>
    <span class="hljs-keyword">int</span> val;
    ListNode *next;
    ListNode(<span class="hljs-keyword">int</span> x) : val(x), next(<span class="hljs-literal">nullptr</span>) {}
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKNodes</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> k)</span> </span>{
        ListNode* dummy = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);
        dummy-&gt;next = head;

        ListNode* pre = dummy;
        ListNode* end = dummy;

        <span class="hljs-keyword">while</span> (end-&gt;next != <span class="hljs-literal">nullptr</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; end != <span class="hljs-literal">nullptr</span>; i++) {
                end = end-&gt;next;
            }
            <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">break</span>;

            ListNode* start = pre-&gt;next;
            ListNode* next = end-&gt;next;

            end-&gt;next = <span class="hljs-literal">nullptr</span>;
            pre-&gt;next = reverseList(start);
            start-&gt;next = next;

            pre = start;
            end = pre;
        }

        <span class="hljs-keyword">return</span> dummy-&gt;next;
    }

    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{
        ListNode* prev = <span class="hljs-literal">nullptr</span>;
        ListNode* current = head;

        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) {
            ListNode* next = current-&gt;next;
            current-&gt;next = prev;
            prev = current;
            current = next;
        }

        <span class="hljs-keyword">return</span> prev;
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    ListNode* head = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);
    head-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);
    head-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);
    head-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">4</span>);
    head-&gt;next-&gt;next-&gt;next-&gt;next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">5</span>);

    Solution solution;
    ListNode* reversedList = solution.reverseKNodes(head, <span class="hljs-number">2</span>);

    <span class="hljs-keyword">while</span> (reversedList != <span class="hljs-literal">nullptr</span>) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; reversedList-&gt;val &lt;&lt; <span class="hljs-string">" "</span>;
        reversedList = reversedList-&gt;next;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-11-hashmap-implementation-hashmap%E5%AE%9E%E7%8E%B0">Question 11: HashMap Implementation (HashMap实现)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>HashMap实现. 可以使用一个链表数组来实现HashMap，其中数组中的每个元素都是一个键值对的链表。键被哈希以确定数组中的索引，然后键值对被插入到相应的链表中。要检索一个值，键被哈希以找到索引，然后在该索引处的链表中遍历以找到键值对。</p>
<h4 id="c-implementation">C++ Implementation</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span> {</span>
<span class="hljs-keyword">public</span>:
    HashMap(<span class="hljs-keyword">int</span> size) : size(size), <span class="hljs-built_in">map</span>(size, <span class="hljs-literal">nullptr</span>) {}

    <span class="hljs-keyword">size_t</span> _get_hash(<span class="hljs-keyword">const</span> K&amp; key) {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::hash&lt;K&gt;{}(key) % size;
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key, <span class="hljs-keyword">const</span> V&amp; value)</span> </span>{
        <span class="hljs-keyword">size_t</span> key_hash = _get_hash(key);
        <span class="hljs-built_in">std</span>::pair&lt;K, V&gt; key_value = <span class="hljs-built_in">std</span>::make_pair(key, value);

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[key_hash] == <span class="hljs-literal">nullptr</span>) {
            <span class="hljs-built_in">map</span>[key_hash] = <span class="hljs-built_in">std</span>::make_unique&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;K, V&gt;&gt;&gt;();
            <span class="hljs-built_in">map</span>[key_hash]-&gt;push_back(key_value);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : *<span class="hljs-built_in">map</span>[key_hash]) {
                <span class="hljs-keyword">if</span> (pair.first == key) {
                    pair.second = value;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                }
            }
            <span class="hljs-built_in">map</span>[key_hash]-&gt;push_back(key_value);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    }

    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">const</span> K&amp; key)</span> </span>{
        <span class="hljs-keyword">size_t</span> key_hash = _get_hash(key);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[key_hash] != <span class="hljs-literal">nullptr</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : *<span class="hljs-built_in">map</span>[key_hash]) {
                <span class="hljs-keyword">if</span> (pair.first == key) {
                    <span class="hljs-keyword">return</span> pair.second;
                }
            }
        }
        <span class="hljs-keyword">return</span> V();
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> size;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;K, V&gt;&gt;&gt; &gt; <span class="hljs-built_in">map</span>;
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function">HashMap&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">hash_map</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;
    hash_map.add(<span class="hljs-string">"apple"</span>, <span class="hljs-number">10</span>);
    hash_map.add(<span class="hljs-string">"banana"</span>, <span class="hljs-number">20</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; hash_map.get(<span class="hljs-string">"apple"</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// Output: 10</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; hash_map.get(<span class="hljs-string">"banana"</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// Output: 20</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-12-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-two-sum-%E5%93%88%E5%B8%8C%E8%A1%A8-hash-map">Question 12: 两数之和 (Two Sum) (哈希表) (Hash Map)</h2>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例：</p>
<p>输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：nums[0] + nums[1] = 2 + 7 = 9，因此返回 [0, 1]。
解决方式
当涉及到 &quot;Two Sum&quot; 问题时，不同的解决方法有不同的思路。</p>
<p>这里给出常见的 4 种解决办法，</p>
<h4 id="%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表：</h4>
<p>遍历数组，将每个元素及其索引存储在哈希表中。
对于每个元素，计算目标值与当前元素的差值，检查差值是否在哈希表中。
优点是时间复杂度为 O(n)，哈希表的查询操作是常数时间的。</p>
<h4 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</h4>
<p>具体而言，使用了一个字典（Python 中的 dict 或者在 C/C++ 中可以用 std::unordered_map）来存储数组中的元素及其索引。</p>
<p>遍历数组时，对于每个元素，计算目标值与当前元素的差值，然后检查差值是否在字典中。如果在字典中找到了差值，就说明找到了符合条件的两个元素，返回它们的索引。</p>
<p>这种方法的优点是时间复杂度较低，为 O(n)，其中 n 是数组的长度。由于哈希表的查询操作是常数时间的，因此这个算法在性能上比一些其他方法更优。</p>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>

<span class="hljs-comment">// 找到两个数的索引，使它们的和等于目标值</span>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; numMap;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); ++i) {
        <span class="hljs-keyword">int</span> complement = target - nums[i];
        
        <span class="hljs-comment">// 检查差值是否在哈希表中</span>
        <span class="hljs-keyword">if</span> (numMap.find(complement) != numMap.end()) {
            result.push_back(numMap[complement]);
            result.push_back(i);
            <span class="hljs-keyword">return</span> result;
        }
        
        <span class="hljs-comment">// 如果差值不在哈希表中，将当前元素及其索引加入哈希表</span>
        numMap[nums[i]] = i;
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = {<span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>};
    <span class="hljs-keyword">int</span> target = <span class="hljs-number">9</span>;

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result = twoSum(nums, target);

    <span class="hljs-comment">// 输出结果</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : result) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</div></code></pre>
<h2 id="question-13-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%93%88%E5%B8%8C%E8%A1%A8">Question 13: 无重复字符的最长子串(滑动窗口) (哈希表)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<ul>
<li>示例 1:</li>
</ul>
<p>输入: s = &quot;abcabcbb&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</p>
<ul>
<li>示例 2:</li>
</ul>
<p>输入: s = &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</p>
<ul>
<li>示例 3:</li>
</ul>
<p>输入: s = &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</p>
<ul>
<li>请设计一个时间复杂度为 O(n) 或是更優解的算法解决此问题。</li>
</ul>
<h4 id="%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF">解题思路</h4>
<p>这个问题可以使用<code>滑动窗口的思想</code>和<code>哈希表</code>来解决，时间复杂度为<code>O(n)</code>。滑动窗口是数组/字符串问题中常用的抽象概念。窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即[i, j)（左闭，右开）。</p>
<p>我们使用哈希集合来检查字符是否重复，使用两个指针表示字符串中的某个子串（的左右边界）。在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串的长度即为当前无重复字符子串的最大长度。
以下是C++的实现：</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s)</span> </span>{
    <span class="hljs-comment">// 哈希集合，记录每个字符是否出现过</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-keyword">char</span>&gt; occ;
    <span class="hljs-comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span>
    <span class="hljs-keyword">int</span> n = s.size();
    <span class="hljs-keyword">int</span> rk = <span class="hljs-number">-1</span>, ans = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// 左指针向右移动一格，移除一个字符</span>
            occ.erase(s[i - <span class="hljs-number">1</span>]);
        }
        <span class="hljs-keyword">while</span> (rk + <span class="hljs-number">1</span> &lt; n &amp;&amp; !occ.count(s[rk + <span class="hljs-number">1</span>])) {
            <span class="hljs-comment">// 不断地移动右指针</span>
            occ.insert(s[rk + <span class="hljs-number">1</span>]);
            ++rk;
            <span class="hljs-comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span>
        }
        ans = <span class="hljs-built_in">std</span>::max(ans, rk - i + <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">return</span> ans;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">"abcabcbb"</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; lengthOfLongestSubstring(s) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<p>这个算法的时间复杂度为O(n)，其中n是字符串的长度。左指针和右指针分别会遍历整个字符串一次。</p>
<p>空间复杂度为O(Σ)，其中Σ表示字符集的大小。在ASCII码中，Σ为128，我们需要O(Σ)的空间来存储哈希集合。在最坏的情况下，整个字符串全部由相同的字符组成，我们需要O(n)的空间来存储哈希集合。</p>
<h2 id="question-14-string-hash-map-%E5%AD%97%E6%AF%8D%E7%95%B0%E4%BD%8D%E8%A9%9E%E5%88%86%E7%B5%84">Question 14: String Hash Map 字母異位詞分組</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>字母异位词分组。给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<ul>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div>输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]
输出:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
</div></code></pre>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>为了解决这个问题，我们可以使用哈希表来存储每个字符串的字母异位词。具体来说，我们遍历字符串数组，对于每个字符串，我们将其排序后的结果作为哈希表的键，原始字符串作为哈希表的值。这样，我们就可以将字母异位词分组在一起。</p>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>

<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&amp; strs)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>, <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; hash_map;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str : strs) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> sorted_str = str;
        <span class="hljs-built_in">std</span>::sort(sorted_str.begin(), sorted_str.end());
        hash_map[sorted_str].push_back(str);
    }

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; result;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; pair : hash_map) {
        result.push_back(pair.second);
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; strs = {<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>};
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;&gt; result = groupAnagrams(strs);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; group : result) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"["</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; str : group) {
            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">","</span>;
        }
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"]"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-comment">// Output: [[eat,tea,ate,],[tan,nat,],[bat,]]</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-15-numeric-hashmap-%E6%9C%80%E9%95%B7%E9%80%A3%E7%BA%8C%E5%AD%90%E6%95%B8%E7%B5%84-%E5%93%88%E5%B8%8C%E8%A1%A8">Question 15: Numeric HashMap 最長連續子數組 (哈希表)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>最長連續子數組。给定一个未排序的整数数组，找到最长连续子序列的长度。要求算法的时间复杂度为 O(n)。</p>
<ul>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div>输入: [100, 4, 200, 1, 3, 2]
输出: 4
解释: 最长连续子序列是 [1, 2, 3, 4]。它的长度是 4。
</div></code></pre>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>为了解决这个问题，我们可以使用哈希表来存储每个元素的连续子序列的长度。具体来说，我们首先将所有元素添加到哈希表中。然后，我们遍历数组，对于每个元素，我们首先判断它的前一个元素是否在哈希表中。如果在，我们将当前元素的连续子序列的长度设置为前一个元素的连续子序列的长度加一。然后，我们更新当前元素的连续子序列的长度。最后，我们更新最长连续子序列的长度。</p>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; hash_map;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) {
        <span class="hljs-keyword">if</span> (hash_map.find(num) == hash_map.end()) {
            <span class="hljs-keyword">int</span> left = hash_map.find(num - <span class="hljs-number">1</span>) != hash_map.end() ? hash_map[num - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> right = hash_map.find(num + <span class="hljs-number">1</span>) != hash_map.end() ? hash_map[num + <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>;
            <span class="hljs-keyword">int</span> sum = left + right + <span class="hljs-number">1</span>;
            hash_map[num] = sum;
            result = <span class="hljs-built_in">std</span>::max(result, sum);
            hash_map[num - left] = sum;
            hash_map[num + right] = sum;
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = {<span class="hljs-number">100</span>, <span class="hljs-number">4</span>, <span class="hljs-number">200</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>};
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; longestConsecutive(nums) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-16-%E7%A7%BB%E5%8B%95%E9%9B%B6move-zeroes%E6%95%B0%E7%BB%84">Question 16: 移動零（Move Zeroes）(数组)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>移动零。给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<ul>
<li>示例：</li>
</ul>
<pre class="hljs"><code><div>输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
</div></code></pre>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>为了解决这个问题，我们可以使用双指针的方式。具体来说，我们使用两个指针，一个指针用于遍历数组，另一个指针用于记录非零元素的位置。在遍历数组的过程中，我们将非零元素移动到数组的前面。最后，我们将数组剩余的位置填充为 0。</p>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>{
    <span class="hljs-keyword">int</span> n = nums.size();
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (right &lt; n) {
        <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) {
            <span class="hljs-built_in">std</span>::swap(nums[left], nums[right]);
            left++;
        }
        right++;
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = {<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>};
    moveZeroes(nums);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.size(); i++) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-17-unique-elements-in-two-arrays-%E6%95%B8%E7%B5%84">Question 17: Unique Elements in Two Arrays (數組)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>两个array 找没有同时在两个array里面的elements，比如 array1 = [1, 2, 3, 4, 5]; array2 = [1, 3, 5, 7, 9]； 那么result = [2, 4, 7, 9]; how to code this?</p>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>This can be efficiently done using set operations in Python, as sets provide a straightforward way to perform union, intersection, difference, and symmetric difference operations.</p>
<p>The most fitting operation for this task is the symmetric difference, which returns a set containing all the elements that are in either of the sets but not in both. This can be done using the ^ operator or the .symmetric_difference() method on sets.</p>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;set&gt;</span></span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt; <span class="hljs-title">find_unique_elements</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&amp; array1, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;&amp; array2)</span> </span>{
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T&gt; <span class="hljs-title">set1</span><span class="hljs-params">(array1.begin(), array1.end())</span></span>;
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T&gt; <span class="hljs-title">set2</span><span class="hljs-params">(array2.begin(), array2.end())</span></span>;

    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T&gt; result;
    <span class="hljs-built_in">std</span>::set_symmetric_difference(set1.begin(), set1.end(), set2.begin(), set2.end(), <span class="hljs-built_in">std</span>::inserter(result, result.begin()));

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T&gt;(result.begin(), result.end());
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; array1 = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>};
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; array2 = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>};
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; result = find_unique_elements(array1, array2);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; num : result) {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  <span class="hljs-comment">// Output: 2 4 7 9</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h2 id="question-18-%E5%82%A8%E5%AD%98%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B0%B4%E9%87%8F-double-pointer-%E6%95%B0%E7%BB%84">Question 18: 储存的最大水量 (Double Pointer) (数组)</h2>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p>
<ul>
<li>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
</li>
<li>
<p>返回容器可以储存的最大水量。</p>
</li>
<li>
<p>说明：你不能倾斜容器。</p>
</li>
<li>
<p>示例：</p>
</li>
</ul>
<pre class="hljs"><code><div>输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
</div></code></pre>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>为了解决这个问题，我们可以使用双指针的方式。具体来说，我们使用两个指针，分别指向数组的左右两端。然后，我们计算当前两个指针之间的水的容量。具体来说，我们首先计算两个指针之间的距离，然后计算两个指针指向的高度的最小值。最后，我们将两个指针向中间移动，直到两个指针相遇。在移动的过程中，我们不断更新水的容量的最大值。</p>
<h4 id="c-%E4%BB%A3%E7%A0%81">C++ 代码</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; height)</span> </span>{
    <span class="hljs-keyword">int</span> n = height.size();
    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> right = n - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (left &lt; right) {
        <span class="hljs-keyword">int</span> distance = right - left;
        <span class="hljs-keyword">int</span> h = <span class="hljs-built_in">std</span>::min(height[left], height[right]);
        result = <span class="hljs-built_in">std</span>::max(result, distance * h);
        <span class="hljs-keyword">if</span> (height[left] &lt; height[right]) {
            left++;
        } <span class="hljs-keyword">else</span> {
            right--;
        }
    }

    <span class="hljs-keyword">return</span> result;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; height = {<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>};
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; maxArea(height) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>

</body>
</html>
